# 独学 コンピュータサイエンス

*(もっと自然な言い方があると感じたら、プルリクエストをするか、私に連絡してください)*

独学のエンジニアやオンライン学習コースの卒業生なら、コンピュータサイエンスを体系的に学ぶ義務があります。 そんなあなたに朗報です！学位プログラムに何年もの時間＆大金を投資することなく、世界標準の教育を独学できます💸

ネットを見渡せばたくさんのリソースがありますが、確実に他よりも優れているものがあります。 「200以上の無料オンラインコース」のリストは不要です。 

あなたは下記の疑問を持っているはずです。

* どの科目を学ぶべきか？そしてその理由は何か？
* 各科目に最適な本やビデオの講義シリーズは何か？

このガイドはこれらの質問に答えます。

### TL:DR

おすすめにある教科書またはビデオ講義のいずれか、理想的には両方を使用して、以下の9つのトピックについて大まかに提示された順序で学習します。 各トピックの100〜200時間の学習を目指してから、必要に応じて復習してください🚀


| 件名  | なぜ勉強するのですか？ | 本  | ビデオ |
| ------------- | ------------- | ------------- | ------------- |
| プログラミング | 再帰のようなことを「全く理解したことがない」人にならないでください。 | Structure and Interpretation of Computer Programs  | Brian Harvey’s Berkeley CS 61A  |
| コンピュータアーキテクチャ | コンピューターが実際にどのように機能するかについての確かな理解がない場合、あなたが行う高レベルの抽象化はすべて脆弱になってしまいます。 | Computer Systems: A Programmer's Perspective | Berkeley CS 61C |
| アルゴリズムとデータ構造 | スタック、キュー、ツリー、グラフなどのユビキタスデータ構造の使用方法がわからない場合、困難な問題を解決することはできません。 | The Algorithm Design Manual | 	Steven Skiena’s lectures |
| CSの数学 | CSは基本的に応用数学の急速に独自進化したものであるため、数学を学ぶことは競争上の優位性をもたらします。 | Mathematics for Computer Science | Tom Leighton’s MIT 6.042J |
| オペレーティングシステム | 作成するコードのほとんどはオペレーティングシステムによって実行されるため、それらがどのように相互作用するかを知っておく必要があります。 | Operating Systems: Three Easy Pieces | Berkeley CS 162 |
| コンピューターネットワーキング | インターネットは大きな問題であることが判明しました。インターネットがその可能性を最大限に引き出すためにどのように機能するかを理解してください。 | Computer Networking: A Top-Down Approach | Stanford CS 144 |
| データベース | データは最も重要なプログラムの中心ですが、データベースシステムが実際にどのように機能するかを理解している人はほとんどいません。 | Readings in Database Systems | Joe Hellerstein’s Berkeley CS 186 |
| 言語とコンパイラ | 言語とコンパイラが実際にどのように機能するかを理解していれば、より良いコードを記述し、新しい言語をより簡単に学ぶことができます。 | Crafting Interpreters | Alex Aiken’s course on edX
| 分散システム | 最近では、ほとんどのシステムが分散システムです。 | Designing Data-Intensive Applications by Martin Kleppmann | MIT 6.824 |

***
### まだ多すぎる？
何年にもわたって9つのトピックを自習するという考えが圧倒されると感じる場合は、2冊の本だけに焦点を当てることをお勧めします。

* 📖 [Computer Systems: A Programmer's Perspective](http://csapp.cs.cmu.edu/3e/home.html)
* 📖 [Designing Data-Intensive Applications](https://www.amazon.com/dp/B06XPJML5D/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1)

私たちの経験では、これら2冊の本は、特にネットワークアプリケーションに取り組んでいる独学のエンジニアやブートキャンプの卒業生に、信じられないほど高い投資効果を提供します。 また、上記の他のトピックやリソースの「ゲートウェイドラッグ」としても機能する場合があります。

***
### なぜコンピュータサイエンスを学ぶのですか？

<img align="right" width="480" src="https://teachyourselfcs.com/bilotta-tweet.png">

ソフトウェアエンジニアには2つのタイプがあります。コンピュータサイエンスを十分に理解して挑戦的で革新的な仕事をする人と、いくつかの高レベルのツールに精通しているためにうまくやっていく人です。

どちらも自分たちをソフトウェアエンジニアと呼んでおり、どちらも初期のキャリアで同様の給与を得る傾向があります。 しかし、タイプ1のエンジニアは、価値のある商業的作業であれ、画期的なオープンソースプロジェクトであれ、技術的リーダーシップであれ、質の高い個人の貢献であれ、時間の経過とともに、より充実した報酬の高い作業に向かって進みます。

タイプ1のエンジニアは、従来の方法で、またはキャリアを通じて絶え間なく学習することによって、コンピュータサイエンスを深く学ぶ方法を見つけます。 タイプ2のエンジニアは通常、基礎となる基盤ではなく特定のツールやテクノロジーを学び、技術的なファッションの流行が変わったときにのみ新しいスキルを習得します。

現在、業界に参入する人の数は急速に増加していますが、CS卒業生の数は比較的落ちつています。 このタイプ2エンジニアの供給過剰は、雇用機会を減らし、業界のより充実した仕事から彼らを遠ざけ始めています。 タイプ1のエンジニアになるために努力している場合でも、単に仕事の安定性を高めたい場合でも、コンピュータサイエンスを学ぶことが唯一の信頼できる道です。

***
## サブジェクトガイド

### プログラミング

<img align="right" width="200" src="https://teachyourselfcs.com/sicp.jpg">

ほとんどの学部CSプログラムは、コンピュータプログラミングの「導入」から始まります。 これらのコースの最高のバージョンは、初心者だけでなく、最初にコーディングを学んだときに有益な概念やプログラミングモデルを見逃した人にも対応しています。

このコンテンツに対する私たちの標準的な推奨事項は、古典的なコンピュータプログラムの構造と解釈です。これは、[本](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)としても[MITビデオ講義のセット](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/)としても無料でオンラインで入手できます。 これらの講義は素晴らしいものですが、私たちのビデオのおすすめは、[ブライアンハーベイのSICP講義](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter)（バークレー校の61Aコース用）です。 これらは、MITの講義よりも洗練されており、新入生を対象としています。

SICPの少なくとも最初の3つの章を読み、演習を行うことをお勧めします。 追加の練習として、[エクササイズ](https://exercism.io/)のような一連の小さなプログラミングの問題に取り組みます。

このガイドが2016年に最初に発行されて以来、最もよく聞かれる質問の1つは、ジョン・デネロが教える61Aのより最近の講義の録画、および/または対応する本 [「作曲プログラム」](https://composingprograms.com/)を推奨するかどうかです。 これは「SICPの伝統に従って」いますが、Pythonを使用しています。 DeNeroのリソースも素晴らしいと思います。一部の学生はそれらを好むかもしれませんが、最初に試すリソースのセットとして、SICP、Scheme、およびBrianHarveyの講義をお勧めします。

どうして？ SICPは、少なくとも潜在的には、コンピューターとプログラミングに関する基本的な信念を変える能力において無類であるためです。 誰もがこれを経験するわけではありません。その本を嫌う人もいれば、最初の数ページを超えない人もいます。 しかし、潜在的に得られるものを考えると、この本を試す価値はあります。

SICPを楽しんで取り組めない場合は、プログラムの作成を試してみてください。 それでも問題が解決しない場合は、[「プログラムの設計方法」](http://htdp.org/)を試してみてください。 どちらも労力に見合わないと思われる場合、おそらくそれはあなたがしばらくの間他のトピックに焦点を合わせ、1年か2年してからプログラミングの分野に戻ったほうがよいというサインです。

最後に、明確化のポイント：このガイドは、プログラミングにまったく慣れていない人を対象としていません。 あなたを、コンピュータサイエンスのバックグラウンドを持たず、知識のギャップを埋めようとしている有能なプログラマーであると想定しています。 「プログラミング」に関するセクションが含まれているのは、学ぶべきことがもっとあるかもしれないということを単に思い出させるためです。 これまでコーディングしたことがないが、コーディングしたい人は、[このようなガイドをお勧めします](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started)。

### コンピュータアーキテクチャ

<img align="right" width="200" src="https://teachyourselfcs.com/csapp.jpg">

コンピュータアーキテクチャ（「コンピュータシステム」または「コンピュータ組織」と呼ばれることもあります）は、ソフトウェアの表面下でのコンピューティングに関する重要な最初の見方です。 私たちの経験では、これは独学のソフトウェアエンジニアの間で最も無視されている分野です。

私たちのお気に入りの入門書は [ComputerSystems：A Programmer's Perspective](http://csapp.cs.cmu.edu/3e/home.html)であり、この本を使用した典型的な入門用コンピュータアーキテクチャコースは、第1章から第6章の[ほとんどをカバーします](http://csapp.cs.cmu.edu/3e/courses.html)。

CS：APPは、実用的でプログラマー指向のアプローチが大好きです。コンピュータアーキテクチャには、本で説明されているものよりもはるかに多くのものがありますが、主に、より速く、より効率的で、より信頼性の高いソフトウェアを作成するために、コンピュータシステムを理解したい人にとっては素晴らしい出発点として役立ちます。

トピックのより穏やかな導入と、ハードウェアとソフトウェアの懸念のバランスの両方を好む人には、「Nand2Tetris」としても知られるコンピューティングシステムの要素をお勧めします。これは、コンピューター内のすべてがどのように機能するかをまとまりのある理解を提供しようとする野心的な本です。各章では、HDLでの基本的な論理ゲートの記述から、CPUとアセンブラー、テトリスゲームのサイズのアプリケーションに至るまで、システム全体の小さな部分を構築します。

本の最初の6章を読み、関連するプロジェクトを完了することをお勧めします。これにより、マシンのアーキテクチャとその上で実行されるソフトウェアとの関係についての理解が深まります。

本の前半（およびそのすべてのプロジェクト）は、[Nand2TetrisのWebサイト](https://www.nand2tetris.org/)から無料で入手できます。 ビデオ付きの[Courseraコース](https://www.coursera.org/learn/build-a-computer)としても利用できます。

シンプルさとまとまりを追求する上で、Nand2Tetrisは詳しさをトレードオフします。 特に、現代のコンピュータアーキテクチャにおける2つの非常に重要な概念は、パイプライン化とメモリ階層ですが、どちらもテキストにはほとんど含まれていません。

Nand2Tetrisのコンテンツに慣れたら、CS：APPに戻るか、パターソンとヘネシーの[コンピュータ構成と設計](https://smile.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269)、優れた、今では古典的なテキストを検討することをお勧めします。 本のすべてのセクションが必須というわけではありません。 特定の読み方については、バークレーの[CS61Cコース](https://inst.eecs.berkeley.edu//~cs61c/sp15/)「コンピュータアーキテクチャの優れたアイデア」に従うことをお勧めします。 講義ノートとラボはオンラインで入手でき、過去の講義はインターネットアーカイブに[あります](https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_)。

### アルゴリズムとデータ構造

<img align="right" height="280" src="https://teachyourselfcs.com/polya.jpg">
<img align="right" height="280" src="https://teachyourselfcs.com/skiena.jpg">

>私が広く推奨する方法は1つだけです。それは、書く前に考えると呼ばれます。

-リチャード ハミング

私たちは、一般的なアルゴリズムとデータ構造に精通していることが、コンピュータサイエンス教育の最も強力な側面の1つであるという、何十年にもわたる一般的な知恵に同意します。 これは、他のすべての研究分野で成果を上げる、一般的な問題解決能力を訓練するのに最適な場所でもあります。

何百冊もの本がありますが、私たちのお気に入りはStevenSkienaによる[アルゴリズム設計マニュアル](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/)です。 彼は明らかにアルゴリズムによる問題解決が大好きで、おおむね、生徒や読者に同様の熱意を抱かせることに成功しています。私たちの意見では、より一般的に提案されている2つのテキスト（CLRSとSedgewick）は、主に実際の問題解決に役立つ資料を学習する人にとっては、少し証明が重すぎる傾向があります。

ビデオ講義を好む人のために、スキーナは寛大にも彼の[講義のビデオをオンラインで](https://www.youtube.com/watch?v=A2bFN3MyNDA&list=PLOtl7M3yp-DX32N0fVIyvn7ipWKNGmwpp)提供しています。 また、[Coursera](https://www.coursera.org/specializations/algorithms)やその他の場所で利用できるTimRoughgardenのコースも非常に気に[入っています](http://timroughgarden.org/videos.html)。 スキーナの講義スタイルとラフガーデンの講義スタイルのどちらを好むかは、個人的な好みの問題になります。 実際には、良い選択肢はたくさんあるので、気に入ったものを見つけた場合は、それを使い続けることをお勧めします。

練習のための、学生にとっての好ましいアプローチは、[Leetcode](https://leetcode.com/)の問題を解くことです。 これらは、質の良い解決策と議論を伴う興味深い問題である傾向があります。 また、競争の激しいソフトウェア会社での技術面接で一般的に使用される質問に対して進捗状況をテストするのにも役立ちます。 勉強の一環として、約100のランダムなリートコード問題を解くことをお勧めします。

最後に、[一般的な問題解決](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)への優れたユニークなガイドとして、いかにして問題をとくかを強くお勧めします。 数学と同じようにコンピュータサイエンスにも適用できます。

### コンピュータサイエンスのための数学

>数学が単純だと信じられないのは、人生がいかに複雑かを知らないからです。

-ジョンフォンノイマン

ある意味で、コンピュータサイエンスは応用数学の大きくなりすぎた分野です。 多くのソフトウェアエンジニアはこれを無視しようとしますが、程度はさまざまですが、直接学習して受け入れることをお勧めします。 そうすることで、そうでない人よりも大きな競争上の優位性が得られます。

CSに最も関連する数学の分野は、広く「離散数学」と呼ばれます。ここで、「離散」は「連続」の反対であり、大まかには微積分以外の興味深い応用数学のトピックを集めたものです。 漠然とした定義を考えると、「離散数学」の全範囲を網羅しようとすることは意味がありません。 より現実的な目標は、論理、組み合わせ論、確率論、集合論、グラフ理論、および暗号化に情報を提供する数論の実用的な理解を構築することです。 線形代数は、コンピューターグラフィックスと機械学習における重要性を考えると、さらに価値のある研究分野です。

離散数学の私たちが提案する出発点は、[ラースロー・ロヴァースによる講義ノートのセットです](http://www.cs.elte.hu/~lovasz/dmbook.ps)。 Lovász教授は、コンテンツを親しみやすく直感的にするための優れた仕事をしたので、これは、より正式なテキストよりも優れた出発点として役立ちます。

より高度な教材については、同じ名前のMITコースの本の長さほどもある講義ノート[コンピュータサイエンスの数学](https://courses.csail.mit.edu/6.042/spring17/mcs.pdf)をお勧めします。 そのコースのビデオ講義も無料で利用でき、離散数学に推奨される[ビデオ講義](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/)です。

線形代数については、[線形代数のエッセンスビデオシリーズ](https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab)から始めて、ギルバートストラングの[本](https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775/)と[ビデオ](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/)の講義を続けて視聴することをお勧めします。

### オペレーティングシステム

<img align="right" width="200" src="https://teachyourselfcs.com/ostep.jpeg">

[オペレーティングシステムの概念](https://www.amazon.com/dp/1118063333/)（「恐竜の本」）と最新の[オペレーティングシステム](https://www.amazon.com/dp/013359162X/)は、オペレーティングシステムに関する「古典的な」本です。 どちらも、明確さの欠如と一般的な学生に対する不親切さで批判を集めています。

オペレーティングシステム：Three Easy Piecesは、[オンライン](http://pages.cs.wisc.edu/~remzi/OSTEP/)で無料で入手できる優れた代替手段です。 私たちは特に本の構造と読みやすさが好きで、演習は価値があると感じています。

OSTEPの後、Unixに関する[Lionの解説](https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/)、[FreeBSDオペレーティングシステムの設計と実装](https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/)、[Mac OS X Internals](https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/)などの「{OSname} Internals」スタイルの本を通じて、特定のオペレーティングシステムの設計上の決定を調査することをお勧めします。 Linuxの場合、RobertLoveの[素晴らしいLinuxカーネル](https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468)開発をお勧めします。

オペレーティングシステムの理解を深める優れた方法は、小さなカーネルのコードを読んで機能を追加することです。 1つの選択肢は、MITのコース用に維持されているUnixV6からANSICおよび[x86](https://pdos.csail.mit.edu/6.828/2016/xv6.html)への移植版であるxv6です。 OSTEPには[xv6実習](http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf)の付録がついており、応用の効く研究課題の優れたアイデアが満載です。

### コンピューターネットワーキング

<img align="right" width="200" src="https://teachyourselfcs.com/top-down.jpg">

>水晶玉を見つめて未来を見ることができません。 インターネットが将来どうなるかは、社会が作るものです。

-ボブ・カーン

ソフトウェアエンジニアリングの多くがWebサーバーとクライアント上にあることを考えると、コンピューターサイエンスの最もすぐに役立つ分野の1つは、コンピューターネットワーキングです。 ネットワーキングを系統的に研究している独学の学生は、彼らが何年もの間取り囲んでいた用語、概念、プロトコルを最終的に理解していることに気付きます。

このトピックに関する私たちのお気に入りの本は、[コンピュータネットワーク：トップダウンアプローチ](https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/)です。 この本の小さなプロジェクトや演習は行う価値があり、特に[オンライン](https://gaia.cs.umass.edu/kurose_ross/wireshark.htm)で寛大にも提供されている「Wiresharkラボ」が気に入っています。

ビデオ講義を好む人には、以前はスタンフォード大学のMOOCプラットフォームであるラグニータ経由で利用できたスタンフォード大学のコンピュータネットワーク入門コースをお勧めしますが、残念ながら現在はYouTubeで非公式の[プレイリスト](https://www.youtube.com/playlist?list=PLvFG2xYBrYAQCyz4Wx3NPoYJOFjvU7g2Z)としてのみ利用できます。

### データベース

<img align="right" width="200" src="https://teachyourselfcs.com/redbook.jpg">
<img align="right" width="200" src="https://teachyourselfcs.com/data-reality.jpg">

データベースシステムについて自己学習するには、他のほとんどのトピックよりも多くの作業が必要です。 これは比較的新しい（つまり、1970年代以降の）研究分野であり、アイデアを秘匿するための強力な商業的インセンティブが支払われています。さらに、多くの潜在的に優れた教科書の著者は、代わりに会社に参加するか、会社を始めることを好みました。

状況を考慮して、私たちは一般的に教科書を避け、バークレー校でのジョーヘラースタインの[データベースコース](https://www.youtube.com/user/CS186Berkeley/videos)であるCS 186の録音から始めて、その後論文を読むように進むことを自己学習者に勧めます。

新入生にとって特に言及する価値のある論文の1つは、[「データベースシステムのアーキテクチャ」](https://dsf.berkeley.edu/papers/fntdb07-architecture.pdf)です。これは、リレーショナルデータベース管理システム（RDBMS）がどのように機能するかについての高レベルの視点を独自に提供します。 これは、さらなる研究のための有用な骨格として役立ちます。

[データベース「レッドブック」](http://www.redbook.io/)としてよく知られているデータベースシステムの読み物は、Peter Bailis、Joe Hellerstein、MichaelStonebrakerが収集・編集した論文を集めたものです。 CS 186コンテンツのレベルの学習を終えた人にとっては、レッドブックが次の目的地になるはずです。

どうしても入門書を使いたい場合は、ラマクリシュナンとゲールケによる[データベース管理システム](https://smile.amazon.com/Database-Management-Systems-Raghu-Ramakrishnan/dp/0072465638/)をお勧めします。 より上級の学生にとって、ジムグレイの[古典的なトランザクション処理：概念と技法は価値](https://www.amazon.com/Transaction-Processing-Concepts-Techniques-Management/dp/1558601902)がありますが、これを最初のリソースとして使用することはお勧めしません。

最後に、データモデリングは、データベースを操作する上で無視され、十分に教えられていない側面です。 このトピックに関する私たちの提案する本は、[データと現実：私たちの不正確な世界における情報の認識と管理に関する時代を超越した視点です](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)。


### 言語とコンパイラ

<img align="right" width="200" src="https://teachyourselfcs.com/dragon.jpg">

>定型的なプログラマーにならないでください。 代わりに、ユーザーや他のプログラマー向けのツールを作成してください。 繊維産業と鉄鋼産業の歴史に注意してください。機械や工具を作りたいですか、それともそれらの機械を操作したいですか？

-コンパイラコースの開始時のRasBodik

ほとんどのプログラマーは言語を学びますが、ほとんどのコンピューター科学者は言語について学びます。 これにより、プログラミングの分野でも、コンピューター科学者はプログラマーよりも明確な利点が得られます。 彼らの知識は一般化されています。 彼らは、単に特定の言語を学んだだけの人よりも、新しい言語の操作をより深くそして迅速に理解することができます。

私たちが提案する紹介テキストは、BobNystromによる優れた[CraftingInterpreters](https://craftinginterpreters.com/contents.html)であり、オンラインで無料で入手できます。 それはよく組織化され、非常に面白く、そして主な目標が単に彼らの言語と言語ツールをよりよく理解することである人々によく適しています。 「課題」のいずれかに興味を持ち続けるように心がけながら、時間をかけてすべてをやり通すことをお勧めします。

より伝統的な推奨事項は、一般に[「ドラゴンブック」](https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)と呼ばれるコンパイラ：原理、技術、ツールです。 残念ながら、これは自習用ではなく、インストラクターがコースの1〜2学期分のトピックを選択するように設計されています。

Dragon Bookを使用することを選択した場合、理想的にはメンターの助けを借りて、トピックを厳選することがほぼ不可欠です。 実際、ドラゴンブックを利用するために推奨されるのは、必要に応じて、ビデオ講義シリーズの補足リファレンスとして使用することです。 おすすめは、[edXのAlexAikenです](https://www.edx.org/course/compilers)。

### 分散システム

<img align="right" width="200" src="https://teachyourselfcs.com/ddia.jpg">

コンピュータは数が増えるにつれて、広く散らばりもしました。以前は企業がますます大きなメインフレームを購入していましたが、今では非常に小さなアプリケーションでも複数のマシンで実行されるのが一般的です。 分散システムは、そうすることに伴うトレードオフについて推論する方法の研究です。

自習のために私たちが提案する本は、MartinKleppmannの[DesigningData-IntensiveApplications](https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/)です。 従来の教科書よりもはるかに優れたDDIAは、開業医向けに設計された非常に読みやすい本であり、詳しさや厳密さを犠牲にすることを何とか回避します。

より伝統的なテキストを探している人、またはオンラインで無料で入手できるテキストを好む人には、マーテン・ヴァン・スティーンとアンドリュー・タネンバウムの[分散システム、第3版](https://www.distributed-systems.net/index.php/books/ds3/)をお勧めします。

ビデオを好む人のために、オンラインで利用できるビデオを備えた優れたコースは、[MITの6.824](https://www.youtube.com/watch?v=cQP8WApzIQQ&list=PLrw6a1wE39_tb2fErI4-WkMbsvGQk9_UB)です。これは、ロバートモリスが教えている[大学院コースです](https://pdos.csail.mit.edu/6.824/schedule.html)。

教科書やその他の二次資料の選択に関係なく、分散システムの研究は絶対に論文を読むことを義務付けています。 良いリストが[ここにあります](http://dsrg.pdos.csail.mit.edu/papers/)。近場の[PapersWeLove](https://paperswelove.org/)の支部に参加することを強くお勧めします。

## よくある質問

#### ❓ このガイドの対象読者は誰ですか？

あなたが独学のソフトウェアエンジニア、ブートキャンプの卒業生、早熟な高校生、または正式な教育を独学で補おうとしている大学生であることを念頭に置いています。 この旅にいつ着手するかという問題は完全に個人的なものですが、ほとんどの人は、CS理論に深く踏み込む前に、専門的な経験を積むことで恩恵を受ける傾向があります。 たとえば、学生はデータベースを専門的に扱ったことがある場合はデータベースシステムについて、ウェブプロジェクトを1つか2つ行ったことがある場合はコンピュータネットワークについて学ぶのが大好きです。

#### ❓ AI / graphics / pet-topic-Xはどうですか？

私たちは、専門分野や業界に関係なく、システムに重点を置いて、すべての実践的なソフトウェアエンジニアが知っておくべきと思われるコンピュータサイエンスのトピックにリストを限定しようとしました。 私たちの経験では、これらは独学のエンジニアやブートキャンプの卒業生の圧倒的多数にとって最高のROIを誇るトピックであり、さらなる研究のための確固たる基盤を提供します。 その後、教科書や論文を手に取って、ほとんどガイダンスなしでコアコンセプトを学べるより良い状態になります。 一般的な「選択科目」のいくつかについて、推奨される出発点は次のとおりです。

* 人工知能の場合：ビデオを見て、優れたパックマンプロジェクトを完了することにより、バークレーの[AIコース入門](http://ai.berkeley.edu/home.html)を行います。 教科書として、ラッセルとノーヴィグの人工知能：現代的なアプローチを使用してください。

* 機械学習の場合：AndrewNgのCourseraコースを受講してください。 ディープラーニングのような輝かしい新しいトピックに挑戦する前に、辛抱強く、基本を理解していることを確認してください。

* コンピュータグラフィックスの場合：バークレーの [CS184](https://inst.eecs.berkeley.edu//~cs184/fa12/onlinelectures.html)資料を読み、[コンピュータグラフィックス：原則と実践](https://www.amazon.com/Computer-Graphics-Principles-Practice-3rd/dp/0321399528)を教科書として使用します。

#### ❓ 提案されたシーケンスはどのくらい厳密ですか？

現実的には、これらの主題はすべてかなりの量の重複があり、周期的に相互に参照しています。 たとえば、離散数学とアルゴリズムの関係を考えてみましょう。最初に数学を学ぶと、アルゴリズムをより深く分析して理解するのに役立ちますが、最初にアルゴリズムを学ぶと、離散数学の動機とコンテキストが大きくなります。 理想的には、キャリアを通じてこれらのトピックの両方を何度も再検討することになるでしょう。

そのため、推奨されるシーケンスは、ほとんどの場合、学習の糸口としてのみ役立ちます。別のシーケンスを好むやむを得ない理由がある場合は、それを選択してください。 私たちの意見で最も重要な「前提条件」は、オペレーティングシステムまたはデータベースの前にコンピュータアーキテクチャを学び、分散システムの前にネットワークとオペレーティングシステムを学ぶことです。

#### ❓ これは、Open Source SocietyやfreeCodeCampカリキュラムとどのように比較されますか？

このガイドが2016年に最初に作成されたとき、[OSSガイド](https://github.com/ossu/computer-science)は主題が多すぎたために、劣ったリソースを提案してしまい、更には、なぜそのコースなのか、ということや、どの側面に価値があるのか、ということに関する説明やガイダンスを提供していませんでした。 専門分野に関係なく、コースのリストをソフトウェアエンジニアとして本当に知っておくべきコースに限定し、各コースが含まれる理由を理解できるように努めました。 その後の数年間で、OSSガイドは改善されましたが、それでも、これはより明確でまとまりのあるパスを提供すると考えています。

freeCodeCampは、コンピュータサイエンスではなく、主にプログラミングに重点を置いています。 コンピュータサイエンスを学びたい理由については、上記 (なぜコンピュータサイエンスを学ぶのですか？)を参照してください。 プログラミングに不慣れな場合は、それを優先し、1、2年後にこのガイドに戻ることをお勧めします。

#### ❓ 言語Xはどうですか？

特定のプログラミング言語を学ぶことは、コンピュータサイエンスの分野について学ぶこととはまったく異なる面にあります。言語を学ぶことは、はるかに簡単で、はるかに価値がありません。 すでにいくつかの言語を知っている場合は、ガイドに従って言語習得をギャップに合わせるか、後で使用することを強くお勧めします。 プログラミングを（コンピュータープログラムの構造と解釈などを通じて）よく学んだ場合、特にコンパイラーを学んだ場合は、新しい言語の基本を学ぶのに週末の休みより少し長くしかかからないはずです。その後、仕事上のライブラリ/ツール/エコシステムについて学ぶことができます。

#### ❓ トレンディなテクノロジーXはどうですか？

単一のテクノロジーは、それを使用することを学ぶことがあなたの教育の中核部分であるべきであるほど重要ではありません。 一方で、そのことについて学ぶことにワクワクしているのは素晴らしいことです。 秘訣は、特定のテクノロジーから基礎となる分野や概念に逆戻りし、流行のテクノロジーが全体像にどのように適合するかを確認する前に、それを深く学ぶことです。

#### ❓ なぜまだ[SICP](https://mitpress.mit.edu/sites/default/files/sicp/index.html)を推奨しているのですか？

ほら、試してみてください。 一部の人々は、SICPにとても強い衝撃を受けています。これは、他のほとんどの本に共通していない特徴です。 気に入らない場合は、いつでも別のことを試して、後でSICPに戻ることができます。

#### ❓ なぜあなたはまだドラゴンの本を推薦しているのですか？

Dragonの本は、今でもコンパイラにとって最も完全な単一のリソースです。 この本は、通常、構文解析など、最近詳細にカバーするのがあまり流行していない特定のトピックを強調しすぎるために、あらぬ非難を受けてしまいます。 重要なのは、この本は、インストラクターがコースを組み立てるのに十分な資料を提供することだけを意図しており、巻頭から巻末までを通して勉強することは決して意図していなかったということです。 同様に、自己学習者は本を通して自分の冒険を選ぶことができますが、公開コースの講師がコースの概要で行った提案に従うほうがよいでしょう。

#### ❓ どうすれば教科書を安く手に入れることができますか？

私たちが提案する教科書の多くは、著者の寛大さのおかげで、オンラインで無料で入手できます。 そうでない場合は、古いエディションの中古コピーを購入することをお勧めします。 原則として、教科書の版が2つ以上ある場合は、古い版で十分である可能性が非常に高くなります。 価格差があったとしても、最新バージョンが古いバージョンより10倍優れている可能性はほとんどありません。

#### ❓ 誰が作ったの？

このガイドは、もともと[OzNova](https://twitter.com/oznova_)と[MylesByrne](https://twitter.com/quackingduck)によって作成され、2020年にOzによって更新されました。 これは、サンフランシスコの小グループ環境でオンラインで生活している1000人以上のほとんど独学のエンジニアとブートキャンプ卒業生に基礎的なコンピュータサイエンスを教えた経験に基づいています。 自己学習リソースに関するフィードバックを継続してくださったすべての生徒に感謝します。

十分な時間とモチベーションがあれば、上記のすべてを自分で学ぶことができると確信しています。 しかし、集中的で構造化されたインストラクター主導のプログラムを好む場合は、[コンピュータサイエンスインテンシブ](https://bradfieldcs.com/csi/)に興味があるかもしれません。 修士号を取得することは[お勧めしません](https://ozwrites.com/masters/)。

#### ✉️  連絡先
hello@bradfieldcs.com

San Francisco, California

© 2016-2020 [Bradfield School of Computer Science](https://bradfieldcs.com/)

***
がんばって！

翻訳者:

[ラルフ 富雄 プラムリー](https://github.com/ralphplumley)

[Ma](https://github.com/ma2442)

[Yoshiki Izumi](https://github.com/minmin0530/)
